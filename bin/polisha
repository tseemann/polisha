#!/usr/bin/env perl
use v5.26;
use strict;
use File::Basename;
use Getopt::Std;
use Cwd qw(abs_path);
use File::Which;
use File::Temp qw(tempdir);
use Term::ANSIColor;
use List::Util qw(min max);

#......................................
my $VERSION = "0.0.2";
my $EXE = basename($0);
my $MAPCALLER = "MapCaller -maxmm 0.02 -alg ksw2 -ploidy 1 -min_cnv 10000000 -min_gap 10000000";

#......................................
my %opt = (d=>10, n=>3, j=>0, s=>1);
@ARGV or usage(1);
getopts('hVf:r:i:o:d:n:j:s:', \%opt);
$opt{h} and usage(0);
$opt{V} and version();
my $R1 = check_file($opt{f}, '-f R1.fq');
my $R2 = check_file($opt{r}, '-r R2.fq');
my $IN = check_file($opt{i}, '-i IN.fa');
my $CPUS = check_int($opt{j} || cpus(), 1, undef, '-j');
my $MAXITER = check_int($opt{n}, 1, 100, '-n');
my $MINDP = check_int($opt{d}, 1, undef, '-m');
my $SAMP = $opt{'s'} || 1.0;
$SAMP > 0 && $SAMP <= 1 or err("-s $SAMP must be (0..1])");

#......................................
msg("This is $EXE $VERSION");
check_tools(qw'pilon minimap2 samtools');

#my $dir = tempdir();
my $dir = './out'; run("mkdir -p $dir");
msg("Work folder:", $dir);

my $fa = fasta2hash($IN);
hash2fasta("$dir/in.fa", $fa);

for my $round (1 .. $MAXITER) {
  banner("Correction round $round");
  my $bam = "$dir/$round.bam";
  bam("$dir/in.fa", $R1, $R2, $bam);
  pilon("$dir/in.fa", $bam, "$dir/$round.fa");   
}

msg("Done.");

#......................................
sub bam {
  my($ref, $r1, $r2, $bam) = @_;
  run("samtools faidx '$ref'");
  run("minimap2 -a -x sr -t $CPUS '$ref' '$r1' '$r2'" 
     ." | samtools view -u -f 2 -"
     ." | samtools sort -@ $CPUS"
     ." > '$bam'");
  run("samtools index '$bam'");
  return;
}

#......................................
sub pilon {
  my($old, $bam, $new) = @_;
  run(
    "_JAVA_OPTS=-Xmx8g pilon --threads $CPUS"
   ." --genome '$old' --frags '$bam'"
   ." --output '$new' --changes --fix bases"
   ." --minqual 13 --minmq 30 --mindepth $MINDP"
   ." --nostrays" 
  );
  return;
}

#......................................
sub version {
  print "$EXE $VERSION\n";
  exit(0);
}
#......................................
sub usage {
  my($ec) = 0;
  select $ec ? \*STDERR : \*STDOUT;
  print 
    "SYNOPSIS\n",
    "  Correct assembly errors with Illumina reads\n",
    "USAGE\n",
    "  $EXE [options] -f R1.fq -r R2.fq -i contigs.fa -o fixed.fa\n",
    "OPTIONS\n",
    "  -h        Print this help\n",
    "  -V        Print version and exit\n",
    "  -f FASTQ  R1 FASTQ fwd reads\n",
    "  -r FASTQ  R2 FASTQ rev reads\n",
    "  -i FASTA  Input contigs\n",
    "  -o FASTA  Output corrected contigs\n",
    "  -d INT    Minimum depth [$opt{d}]\n",
    "  -n INT    Maximum correction rounds [$opt{n}]\n",
    "  -s FLOAT  Subsample reads for speed [$opt{s}]\n",
    "  -j CPUS   NUmber of threads [$opt{j}]\n",
    "END\n";
  print 
  exit($ec);
}
#......................................
sub msg {
  print STDERR "@_\n";
}
#......................................
sub err {
  msg("ERROR:", @_);
  exit(-1);
}
#......................................
sub run {
  msg("Running:", color('blue'), @_, color('reset'));
  system(@_)==0 or 
    err("$! | could not run:", @_);
}
#......................................
sub check_tools {
  for my $exe (@_) {
    my $path = which($exe);
    $path 
      ? msg("Found $exe - $path")
      : err("Could not find $exe - plase install it")
      ;    
  }
}
#......................................
sub check_file {
  my($fn, $msg) = @_;
  $msg ||= 'file';
  $fn or err("Please provide $msg");
  -r $fn or err("Can't read $msg '$fn'");
  return abs_path($fn);
}
#......................................
sub check_int {
  my($x, $min, $max, $msg) = @_;
  defined($x) or err("$msg has no value");
  $x =~ m/^-?\d+$/ or err("$msg '$x' is not an integer");
  err("$msg $x must be >= $min")
    if defined($min) && $x < $min;
  err("$msg $x must be <= $max")
    if defined($max) && $x > $max;
  return $x;  
}

#......................................
sub cpus {
  my($cpus) = qx"nproc";
  $cpus ||= 1;
  chomp $cpus;
  return $cpus;
}

#......................................
sub banner {
  my $text = " @_ ";
  #my($W) = GetTerminalSize(); # WC,HC,WP,HP
  my $W = qx'tput cols';
  chomp $W;
  my $X = '='x($W-1);
  print STDERR 
    color('green'),
    $X, "\n", $text, "\n", $X, "\n",
    color('reset');
}

#......................................
sub fasta2hash {
  my($fname) = @_;
  my %seq;
  my($id,$dna,$bp);
  open my $FASTA, '<', $fname;
  while (<$FASTA>) {
    chomp;
    if (m/^>(\S+)/) {
      $id = $1;
    }
    else {
      $seq{$id} .= $_;
      $bp += length;
    }
  }
  close $FASTA;
  for my $id (keys %seq) {
    $seq{$id} =~ s/[^AGTC]/N/gi;
  }
  my $N = scalar keys %seq;
  msg("Loaded $N contigs totalling $bp bp");
  return \%seq;
}

#......................................
sub hash2fasta {
  my($fname,$seq) = @_;
  my $N = scalar keys %$seq;
  msg("Writing $N contigs to: $fname");
  open my $FASTA, '>', $fname;
  for my $id (sort keys %$seq) {
    print $FASTA ">", $id, "\n", 
                  $seq->{$id}, "\n";
  }
  close $FASTA;
}

#......................................


#......................................

__DATA__
#    run("$MAPCALLER -r $dir/in.fa -f '$R1' -f2 '$R2'"
#       ." -t $CPUS -ad $MINDP"
#       ." -vcf $vcf -log $vcf.log 1> $vcf.out 2> $vcf.err");
#    run(qq,bcftools filter -Oz -i 'FILTER="PASS"' $vcf > $vcf.gz,);
    #run("bcftools convert -Oz $vcf > $vcf.gz");
#    run("bcftools index $vcf.gz");
#    run("bcftools consensus -f $dir/in.fa $vcf.gz > $dir/out.fa");
