#!/usr/bin/env perl
use v5.26;
use strict;
use File::Basename;
use Getopt::Std;
use Cwd qw(abs_path);
use File::Which;
use File::Temp qw(tempdir);
use Term::ANSIColor;

#......................................
my $VERSION = "0.0.2";
my $EXE = basename($0);
my $MAPCALLER = "MapCaller -maxmm 0.02 -alg ksw2 -ploidy 1 -min_cnv 10000000 -min_gap 10000000";

#......................................
my %opt = (d=>10, n=>3, j=>0);
@ARGV or usage(1);
getopts('hVf:r:i:o:d:r:j:', \%opt);
$opt{h} and usage(0);
$opt{V} and version();
my $R1 = check_file($opt{f}, '-f R1.fq');
my $R2 = check_file($opt{r}, '-r R2.fq');
my $IN = check_file($opt{i}, '-i IN.fa');
my $CPUS = check_int($opt{j} || cpus(), 1, undef, '-j');
my $MAXITER = check_int($opt{n}, 1, 100, '-n');
my $MINDP = check_int($opt{d}, 1, undef, '-m');

#......................................
msg("This is $EXE $VERSION");
#check_tools(qw'pilon bcftools samtools minimap2');
check_tools(qw'seqkit MapCaller bcftools');
#my $dir = tempdir();
my $dir = './out'; run("mkdir -p $dir");
msg("Work folder:", $dir);

my $fa = fasta2hash($IN);
hash2fasta("$dir/in.fa", $fa);

for (my $iter=1; $iter <= $MAXITER; $iter++) {
  for my $rot (0, 1) {
    my $round = "$iter.$rot";
    banner("Correction round $round");
    my $vcf = "$dir/$round.vcf";
    run("$MAPCALLER -r '$IN' -f '$R1' -f2 '$R2'"
       ." -t $CPUS -ad $MINDP"
       ." -vcf $vcf -log $vcf.log 1> $vcf.out 2> $vcf.err");
    run("bcftools convert -Oz $vcf > $vcf.gz");
    run("bcftools index $vcf.gz");
  }
}

msg("Done.");

#......................................
sub version {
  print "$EXE $VERSION\n";
  exit(0);
}
#......................................
sub usage {
  my($ec) = 0;
  select $ec ? \*STDERR : \*STDOUT;
  print 
    "SYNOPSIS\n",
    "  Correct assembly errors with Illumina reads\n",
    "USAGE\n",
    "  $EXE [options] -f R1.fq -r R2.fq -i contigs.fa -o fixed.fa\n",
    "OPTIONS\n",
    "  -h        Print this help\n",
    "  -V        Print version and exit\n",
    "  -f FASTQ  R1 FASTQ fwd reads\n",
    "  -r FASTQ  R2 FASTQ rev reads\n",
    "  -i FASTA  Input contigs\n",
    "  -o FASTA  Output corrected contigs\n",
    "  -d INT    Minimum depth [$opt{d}]\n",
    "  -n INT    Maximum correction rounds [$opt{n}]\n",
    "  -j CPUS   NUmber of threads [$opt{j}]\n",
    "END\n";
  print 
  exit($ec);
}
#......................................
sub msg {
  print STDERR "@_\n";
}
#......................................
sub err {
  msg("ERROR:", @_);
  exit(-1);
}
#......................................
sub run {
  msg("Running:", @_);
  system(@_)==0 or 
    err("$! | could not run:", @_);
}
#......................................
sub check_tools {
  for my $exe (@_) {
    my $path = which($exe);
    $path 
      ? msg("Found $exe - $path")
      : err("Could not find $exe - plase install it")
      ;    
  }
}
#......................................
sub check_file {
  my($fn, $msg) = @_;
  $msg ||= 'file';
  $fn or err("Please provide $msg");
  -r $fn or err("Can't read $msg '$fn'");
  return abs_path($fn);
}
#......................................
sub check_int {
  my($x, $min, $max, $msg) = @_;
  defined($x) or err("$msg has no value");
  $x =~ m/^-?\d+$/ or err("$msg '$x' is not an integer");
  err("$msg $x must be >= $min")
    if defined($min) && $x < $min;
  err("$msg $x must be <= $max")
    if defined($max) && $x > $max;
  return $x;  
}

#......................................
sub cpus {
  my($cpus) = qx"nproc";
  $cpus ||= 1;
  chomp $cpus;
  return $cpus;
}

#......................................
sub banner {
  my $text = " @_ ";
  #my($W) = GetTerminalSize(); # WC,HC,WP,HP
  my $W = qx'tput cols';
  chomp $W;
  my $X = '='x($W-1);
  print STDERR 
    color('green'),
    $X, "\n", $text, "\n", $X, "\n",
    color('reset');
}

#......................................
sub fasta2hash {
  my($fname) = @_;
  my %seq;
  my($id,$dna,$bp);
  open my $FASTA, '<', $fname;
  while (<$FASTA>) {
    chomp;
    if (m/^>(\S+)/) {
      $id = $1;
    }
    else {
      $seq{$id} .= $_;
      $bp += length;
    }
  }
  close $FASTA;
  my $N = scalar keys %seq;
  msg("Loaded $N contigs totalling $bp bp");
  return \%seq;
}

#......................................
sub hash2fasta {
  my($fname,$seq) = @_;
  my $N = scalar keys %$seq;
  msg("Writing $N contigs to: $fname");
  open my $FASTA, '>', $fname;
  for my $id (sort keys %$seq) {
    print $FASTA ">", $id, "\n", 
                  $seq->{$id}, "\n";
  }
  close $FASTA;
}

#......................................


#......................................


